
\section{Conclusion}
\begin{frame}{Conclusion}

\begin{block}{Conclusion}
\begin{itemize}

\item We proposed a synchronous monitoring algorithm that copes with $f$ crash failures in a distributed setting. The algorithm solves the synchronous monitoring problem in \Def{$f +1$} rounds of communication and reduces the message size overhead from $|\AP|$ to \Def{$\log(m_\monstate)$}.

\ \\

\item We proposed an algorithm for distributed crash-resilient asynchronous RV that \Def{consistently} monitors the system under inspection with \Def{no communication} between monitors. 

\end{itemize}
\end{block}
\end{frame}



\section{Future Work}
\begin{frame}{Future Work}

\begin{block}{Futur Work}
\begin{itemize}

\item To address more severe faults, e.g., Byzantine failures. 

\ \\

\item To have monitors observe, communicate, and emit verdicts between any two global states.

\ \\ 

\item To extend our results to the case where the input to the monitors is a sequence of global states and each monitor produces a sequence of verdict sets, one per each global state


\end{itemize}
\end{block}
\end{frame}



